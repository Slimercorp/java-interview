[Вопросы для собеседования](README.md)

# Базы данных

+ [Что такое _«база данных»_?](#Что-такое-база-данных)[Junior]
+ [Что такое _«система управления базами данных»_?](#Что-такое-система-управления-базами-данных)[Junior]
+ [Что такое _«реляционная модель данных»_?](#Что-такое-реляционная-модель-данных)[Junior]
+ [Дайте определение терминам _«простой»_, _«составной» (composite)_, _«потенциальный» (candidate)_ и _«альтернативный» (alternate)_ ключ.](#Дайте-определение-терминам-простой-составной-composite-потенциальный-candidate-и-альтернативный-alternate-ключ)[Junior]
+ [Что такое _«первичный ключ» (primary key)_? Каковы критерии его выбора?](#Что-такое-первичный-ключ-primary-key-Каковы-критерии-его-выбора)[Junior]
+ [Что такое _«внешний ключ» (foreign key)_?](#Что-такое-внешний-ключ-foreign-key)[Junior]
+ [Что такое _«нормализация»_?](#Что-такое-нормализация)[Junior]
+ [Какие существуют нормальные формы?](#Какие-существуют-нормальные-формы)[Middle+]
+ [Что такое _«денормализация»_? Для чего она применяется?](#Что-такое-денормализация-Для-чего-она-применяется)[Junior]
+ [Какие существуют типы связей в базе данных? Приведите примеры.](#Какие-существуют-типы-связей-в-базе-данных-Приведите-примеры)[Junior]
+ [Что такое _«индексы»_? Для чего их используют? В чём заключаются их преимущества и недостатки?](#Что-такое-индексы-Для-чего-их-используют-В-чём-заключаются-их-преимущества-и-недостатки)[Junior]
+ [Какие типы индексов существуют?](#Какие-типы-индексов-существуют)[MIddle+]
+ [В чем отличие между кластерными и некластерными индексами?](#В-чем-отличие-между-кластерными-и-некластерными-индексами)[Middle+]
+ [Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?](#Имеет-ли-смысл-индексировать-данные-имеющие-небольшое-количество-возможных-значений)[Middle+]
+ [Когда полное сканирование набора данных выгоднее доступа по индексу?](#Когда-полное-сканирование-набора-данных-выгоднее-доступа-по-индексу)[Middle+]
+ [Что такое _«транзакция»_?](#Что-такое-транзакция)[Junior]
+ [Назовите основные свойства транзакции.](#Назовите-основные-свойства-транзакции)[Junior]
+ [Какие существуют уровни изолированности транзакций?](#Какие-существуют-уровни-изолированности-транзакций)[Middle+]
+ [Какие проблемы могут возникать при параллельном доступе с использованием транзакций?](#Какие-проблемы-могут-возникать-при-параллельном-доступе-с-использованием-транзакций)[Middle+]

## Что такое _«база данных»_? [Junior]

__База данных__ — организованный и адаптированный для обработки вычислительной системой набор информации.

База данных (Database) - это организованная коллекция данных, которая хранится и управляется с помощью компьютерной системы. База данных может содержать информацию об объектах, событиях, процессах, людях и т.д. В более широком смысле, база данных - это система управления данными, которая позволяет пользователям создавать, хранить, изменять и извлекать данные.

[к оглавлению](#Базы-данных)

## Что такое _«система управления базами данных»_? [Junior]

__Система управления базами данных (СУБД)__ - набор средств общего или специального назначения, обеспечивающий создание, доступ к материалам и управление базой данных.

Основные функции СУБД:

+ управление данными
+ журнализация изменений данных
+ резервное копирование и восстановление данных;
+ поддержка языка определения данных и манипулирования ими.

__Система управления базами данных (СУБД)__ - это программное обеспечение, которое позволяет пользователям создавать, управлять, хранить и извлекать данные из базы данных. Она является промежуточным слоем между пользователем и базой данных и обеспечивает эффективный и безопасный доступ к данным.

СУБД обычно включает в себя следующие компоненты:

+ Сервер баз данных: обеспечивает доступ к базе данных и управляет ее содержимым;
+ Инструменты администрирования: позволяют администраторам баз данных создавать и настраивать базы данных, управлять правами доступа и выполнением запросов;
+ Язык запросов: позволяет пользователям создавать запросы для извлечения данных из базы данных;
+ Интерфейс пользователя: обеспечивает пользовательский доступ к данным через графический интерфейс или командную строку.

[к оглавлению](#Базы-данных)

## Что такое _«реляционная модель данных»_? [Junior]

__Реляционная модель данных__ — это логическая модель данных и прикладная теория построения реляционных баз данных.

Реляционная модель данных - это модель организации и хранения данных в базе данных, где данные представляются в виде таблиц, состоящих из строк и столбцов. Каждая таблица в реляционной модели представляет определенный тип объектов или сущностей, которые можно связывать между собой с помощью ключей.

Основными элементами реляционной модели данных являются:

+ Таблицы: основные единицы хранения данных, представленные в виде двумерных таблиц с наборами строк и столбцов. Каждая строка таблицы представляет конкретный объект или экземпляр сущности, а каждый столбец представляет атрибуты или свойства этой сущности.
+ Ключи: связующие элементы между таблицами и строками, используемые для определения отношений между различными сущностями. Ключи могут быть первичными (primary) и внешними (foreign), которые связывают таблицы между собой.
+ Ограничения целостности: правила, которые обеспечивают целостность данных и защищают базу данных от ошибок и неконсистентности. Например, ограничение уникальности позволяет гарантировать, что значения в столбце таблицы не повторяются, а ограничение внешнего ключа - что связи между таблицами не нарушаются.

Реляционная модель данных включает в себя следующие компоненты:

+ _Структурный аспект_ — данные представляют собой набор отношений.
+ _Аспект целостности_ — отношения отвечают определенным условиям целостности: уровня домена (типа данных), уровня отношения и уровня базы данных.
+ _Аспект обработки (манипулирования)_ — поддержка операторов манипулирования отношениями (реляционная алгебра, реляционное исчисление).
+ _Нормальная форма_ - свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности и определённое как совокупность требований, которым должно удовлетворять отношение.

[к оглавлению](#Базы-данных)

## Дайте определение терминам _«простой»_, _«составной» (composite)_, _«потенциальный» (candidate)_ и _«альтернативный» (alternate)_ ключ. [Junior]

__Простой ключ__ состоит из одного атрибута (поля). __Составной__ - из двух и более.

__Потенциальный ключ__ - простой или составной ключ, который уникально идентифицирует каждую запись набора данных. При этом потенциальный ключ должен обладать критерием неизбыточности: при удалении любого из полей набор полей перестает уникально идентифицировать запись.

Из множества всех потенциальных ключей набора данных выбирают первичный ключ, все остальные ключи называют __альтернативными__.

__Простой ключ (simple key)__ - это ключ, состоящий из одного атрибута или столбца в таблице, который уникально идентифицирует каждую строку в таблице. Например, в таблице клиентов, идентификатор клиента может быть использован как простой ключ.

__Составной ключ (composite key)__ - это ключ, состоящий из нескольких атрибутов или столбцов в таблице, который уникально идентифицирует каждую строку в таблице. Например, в таблице заказов, составной ключ может быть составлен из идентификатора заказа и даты заказа, чтобы гарантировать уникальность каждого заказа.

__Потенциальный ключ (candidate key)__ - это атрибут или комбинация атрибутов в таблице, которые могут быть использованы в качестве уникального идентификатора каждой строки в таблице. Например, в таблице сотрудников, идентификатор сотрудника и номер социального страхования могут быть использованы в качестве потенциального ключа.

__Альтернативный ключ (alternate key)__ - это атрибут или комбинация атрибутов в таблице, которые могут быть использованы в качестве уникального идентификатора каждой строки в таблице, но не выбраны в качестве основного ключа. Например, в таблице заказов, номер заказа может быть использован как альтернативный ключ, если идентификатор заказа и дата заказа используются в качестве составного ключа.

[к оглавлению](#Базы-данных)

## Что такое _«первичный ключ» (primary key)_? Каковы критерии его выбора? [Junior]

__Первичный ключ (primary key)__ в реляционной модели данных один из _потенциальных ключей_ отношения, выбранный в качестве основного ключа (ключа по умолчанию).

Если в отношении имеется единственный потенциальный ключ, он является и первичным ключом. Если потенциальных ключей несколько, один из них выбирается в качестве первичного, а другие называют _«альтернативными»_.

В качестве первичного обычно выбирается тот из потенциальных ключей, который наиболее удобен. Поэтому в качестве первичного ключа, как правило, выбирают тот, который имеет наименьший размер (физического хранения) и/или включает наименьшее количество атрибутов. Другой критерий выбора первичного ключа — сохранение его уникальности со временем. Поэтому в качестве первичного ключа стараются выбирать такой потенциальный ключ, который с наибольшей вероятностью никогда не утратит уникальность.

[к оглавлению](#Базы-данных)

## Что такое _«внешний ключ» (foreign key)_? [Junior]

__Внешний ключ (foreign key)__ — подмножество атрибутов некоторого отношения A, значения которых должны совпадать со значениями некоторого потенциального ключа некоторого отношения B.

В SQL, внешний ключ (foreign key) - это ограничение целостности (constraint), которое связывает поле или набор полей в одной таблице со значениями поля (или набором полей) в другой таблице.

Внешний ключ определяет отношение между двумя таблицами, и позволяет обеспечить согласованность данных между ними. Это означает, что значения в столбце, который является внешним ключом в одной таблице, должны совпадать с значениями в столбце, который является первичным ключом в другой таблице.

В основном, внешние ключи используются для связи таблиц в отношениях «один-ко-многим» (one-to-many) или «многие-ко-многим» (many-to-many). Например, если у вас есть таблица заказов и таблица клиентов, то можно создать внешний ключ в таблице заказов, который ссылается на первичный ключ таблицы клиентов, чтобы связать заказы с конкретными клиентами.

Кроме того, внешние ключи могут использоваться для автоматического обновления и удаления связанных записей в других таблицах при внесении изменений в основную таблицу.

[к оглавлению](#Базы-данных)

## Что такое _«нормализация»_? [Junior]

_Нормализация_ - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс замены исходной схемы другой схемой, в которой наборы данных имеют более простую и логичную структуру).

Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.

Нормализация (Normalization) - это процесс проектирования базы данных, в результате которого она структурируется и оптимизируется с целью устранения повторяющихся данных и сокращения дублирования информации.

Цель нормализации - это разбиение больших таблиц на более мелкие, более унифицированные и логически связанные таблицы, чтобы обеспечить целостность данных и снизить возможность ошибок и противоречий в базе данных. Она помогает устранить избыточные данные, снизить размер таблиц, повысить скорость выполнения запросов и обеспечить более эффективное использование хранилища данных.

[к оглавлению](#Базы-данных)

## Какие существуют нормальные формы? [Middle+]

__Первая нормальная форма (1NF)__ - Отношение находится в 1NF, если значения всех его атрибутов атомарны (неделимы). Таблица должна быть представлена в виде двумерной структуры с уникальным идентификатором для каждой строки. 

__Вторая нормальная форма (2NF)__ - Отношение находится в 2NF, если оно находится в 1NF, и при этом все неключевые атрибуты зависят только от ключа целиком, а не от какой-то его части. Таблица должна быть в 1NF и каждый не ключевой атрибут должен зависеть от всего составного первичного ключа.

__Третья нормальная форма (3NF)__ - Отношение находится в 3NF, если оно находится в 2NF и все неключевые атрибуты не зависят друг от друга. Таблица должна быть в 2NF и каждый не ключевой атрибут должен зависеть только от первичного ключа, а не от других не ключевых атрибутов.

__Четвёртая нормальная форма (4NF)__ - Отношение находится в 4NF , если оно находится в 3NF и если в нем не содержатся независимые группы атрибутов, между которыми существует отношение «многие-ко-многим».

__Пятая нормальная форма (5NF)__ - Отношение находится в 5NF, когда каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.

__Шестая нормальная форма (6NF)__ - Отношение находится в 6NF, когда она удовлетворяет всем нетривиальным зависимостям соединения, т.е. когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная отношения, которая находится в 6NF, также находится и в 5NF. Введена как обобщение пятой нормальной формы для хронологической базы данных.

__Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF)__ - Отношение находится в BCNF, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ. Таблица должна быть в 3NF и каждый определитель (атрибут, который определяет значение другого атрибута) должен быть ключом или составной частью ключа.

__Доменно-ключевая нормальная форма (DKNF)__ -  Отношение находится в DKNF, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение.

[к оглавлению](#Базы-данных)

## Что такое _«денормализация»_? Для чего она применяется? [Junior]

__Денормализация базы данных__ — это процесс осознанного приведения базы данных к виду, в котором она не будет соответствовать правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных.

__Денормализация (Denormalization)__ - это процесс добавления повторяющихся данных в базу данных для ускорения выполнения запросов и улучшения производительности. Денормализация нарушает принципы нормализации и может привести к повторению данных в разных таблицах, но может быть полезна в случаях, когда производительность становится приоритетом.

Денормализация может быть использована в следующих случаях:

+ Ускорение выполнения запросов: повторение данных в разных таблицах может уменьшить количество соединений между таблицами и сократить время выполнения запросов, особенно для сложных запросов и больших объемов данных.

+ Упрощение выполнения запросов: повторение данных может упростить написание запросов, так как данные уже содержатся в одной таблице, и не требуется объединение с другими таблицами.

+ Улучшение производительности при масштабировании: повторение данных может быть полезно при масштабировании базы данных, когда несколько копий базы данных размещаются на разных серверах, и уменьшение объема соединений между таблицами может улучшить производительность.

+ Предварительное вычисление: повторение данных может быть использовано для предварительного вычисления или подготовки данных, которые будут использоваться для выполнения запросов.

Однако, денормализация также имеет свои недостатки, включая увеличение размера базы данных, увеличение сложности обновления данных и потенциальное нарушение целостности данных. Поэтому, денормализация должна быть использована с осторожностью и только в тех случаях, когда это необходимо для улучшения производительности системы.

[к оглавлению](#Базы-данных)

## Какие существуют типы связей в базе данных? Приведите примеры. [Junior]

+ __Один к одному__ - любому значению атрибута А соответствует только одно значение атрибута В, и наоборот.

> Каждый университет гарантированно имеет 1-го ректора: _1 университет → 1 ректор_.

+ __Один ко многим__ - любому значению атрибута А соответствует 0, 1 или несколько значений атрибута В.

> В каждом университете есть несколько факультетов: _1 университет → много факультетов_.

+ __Многие ко многим__ - любому значению атрибута А соответствует 0, 1 или несколько значений атрибута В, и любому значению атрибута В соответствует 0, 1 или несколько значение атрибута А.

> 1 профессор может преподавать на нескольких факультетах, в то же время на 1-ом факультете может преподавать несколько профессоров: _Несколько профессоров ↔ Несколько факультетов_.

[к оглавлению](#Базы-данных)

## Что такое _«индексы»_? Для чего их используют? В чём заключаются их преимущества и недостатки? [Junior]

__Индекс (index)__ — объект базы данных, создаваемый с целью повышения производительности выборки данных. 

Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра набора данных запись за записью может занимать много времени. Индекс формируется из значений одного или нескольких полей и указателей на соответствующие записи набора данных, - таким образом, достигается значительный прирост скорости выборки из этих данных.

Индекс (Index) - это структура данных, которая позволяет быстро и эффективно искать данные в базе данных. Индексы создаются на одном или нескольких столбцах таблицы и содержат отсортированные значения столбца и указатели на соответствующие строки таблицы.

Индексы используются для ускорения выполнения запросов и снижения времени, необходимого для извлечения данных из базы данных. Они позволяют быстро находить нужные данные, уменьшают количество чтений из диска и обеспечивают быстрый доступ к данным, что улучшает производительность системы.

Преимущества

+ ускорение поиска и сортировки по определенному полю или набору полей.
+ обеспечение уникальности данных.
+ Ускорение выполнения запросов: индексы позволяют быстро находить нужные данные и снижают время выполнения запросов.
+ Уменьшение количества чтений с диска: индексы обеспечивают быстрый доступ к данным, что уменьшает количество чтений с диска и улучшает производительность системы.
+ Улучшение производительности при больших объемах данных: индексы позволяют быстро находить нужные данные, даже при больших объемах данных, что улучшает производительность системы.

Недостатки 

+ требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса.
+ замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы.
+ Усложнение структуры базы данных: использование большого количества индексов может усложнить структуру базы данных и затруднить ее поддержку.

Использование индексов должно быть обдуманным и основываться на конкретных потребностях и требованиях к базе данных. Индексы следует создавать на наиболее часто используемых столбцах таблицы и избегать их создания на ненужных или малоиспользуемых столбцах.

Индексы предпочтительней для:

+ Поля-счетчика, чтобы в том числе избежать и повторения значений в этом поле;
+ Поля, по которому проводится сортировка данных;
+ Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее;
+ Поля, которое объявлено первичным ключом (primary key);
+ Поля, в котором данные выбираются из некоторого диапазона. В этом случае как только будет найдена первая запись с нужным значением, все последующие значения будут расположены рядом.

Использование индексов нецелесообразно для:

+ Полей, которые редко используются в запросах;
+ Полей, которые содержат всего два или три значения, например: _мужской_,  _женский пол_ или значения _«да»_, _«нет»_.

[к оглавлению](#Базы-данных)

## Какие типы индексов существуют? [Middle+]

__По порядку сортировки__

+ _упорядоченные_ — индексы, в которых элементы упорядочены;
+ _возрастающие_;
+ _убывающие_;
+ _неупорядоченные_ — индексы, в которых элементы неупорядочены.

__По источнику данных__

+ _индексы по представлению (view)_;
+ _индексы по выражениям_.

__По воздействию на источник данных__

+ _кластерный индекс_ - при определении в наборе данных физическое расположение данных перестраивается в соответствии со структурой индекса. Логическая структура набора данных в этом случае представляет собой скорее словарь, чем индекс. Данные в словаре физически упорядочены, например по алфавиту. Кластерные индексы могут дать существенное увеличение производительности поиска данных даже по сравнению с обычными индексами. Увеличение производительности особенно заметно при работе с последовательными данными.
+ _некластерный индекс_ — наиболее типичные представители семейства индексов. В отличие от кластерных, они не перестраивают физическую структуру набора данных, а лишь организуют ссылки на соответствующие записи. Для идентификации нужной записи в наборе данных некластерный индекс организует специальные указатели, включающие в себя: информацию об идентификационном номере файла, в котором хранится запись; идентификационный номер страницы соответствующих данных; номер искомой записи на соответствующей странице; содержимое столбца.

__По структуре__

+ _B*-деревья_;
+ _B+-деревья_;
+ _B-деревья_;
+ _Хэши_.

__По количественному составу__

+ _простой индекс (индекс с одним ключом)_ — строится по одному полю;
+ _составной (многоключевой, композитный) индекс_ — строится по нескольким полям при этом важен порядок их следования;
+ _индекс с включенными столбцами_ — некластеризованный индекс, дополнительно содержащий кроме ключевых столбцов еще и неключевые;
+ _главный индекс (индекс по первичному ключу)_ — это тот индексный ключ, под управлением которого в данный момент находится набор данных. Набор данных не может быть отсортирован по нескольким индексным ключам одновременно. Хотя, если один и тот же набор данных открыт одновременно в нескольких рабочих областях, то у каждой копии набора данных может быть назначен свой главный индекс.

__По характеристике содержимого__

+ _уникальный индекс_ состоит из множества уникальных значений поля;
+ _плотный индекс_ (NoSQL) — индекс, при котором, каждом документе в индексируемой коллекции соответствует запись в индексе, даже если в документе нет индексируемого поля.
+ _разреженный индекс_ (NoSQL) — тот, в котором представлены только те документы, для которых индексируемый ключ имеет какое-то определённое значение (существует).
+ _пространственный индекс_ — оптимизирован для описания географического местоположения. Представляет из себя многоключевой индекс состоящий из широты и долготы.
+ _составной пространственный индекс_ — индекс, включающий в себя кроме широты и долготы ещё какие-либо мета-данные (например теги). Но географические координаты должны стоять на первом месте.
+ _полнотекстовый (инвертированный) индекс_ — словарь, в котором перечислены все слова и указано, в каких местах они встречаются. При наличии такого индекса достаточно осуществить поиск нужных слов в нём и тогда сразу же будет получен список документов, в которых они встречаются.
+ _хэш-индекс_ предполагает хранение не самих значений, а их хэшей, благодаря чему уменьшается размер (а, соответственно, и увеличивается скорость их обработки) индексов из больших полей. Таким образом, при запросах с использованием хэш-индексов, сравниваться будут не искомое со значения поля, а хэш от искомого значения с хэшами полей.
  Из-за нелинейнойсти хэш-функций данный индекс нельзя сортировать по значению, что приводит к невозможности использования в сравнениях больше/меньше и «is null». Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий.
+ _битовый индекс (bitmap index)_ — метод битовых индексов заключается в создании отдельных битовых карт (последовательностей 0 и 1) для каждого возможного значения столбца, где каждому биту соответствует запись с индексируемым значением, а его значение равное 1 означает, что запись, соответствующая позиции бита содержит индексируемое значение для данного столбца или свойства.
+ _обратный индекс (reverse index)_ — B-tree индекс, но с реверсированным ключом, используемый в основном для монотонно возрастающих значений (например, автоинкрементный идентификатор) в OLTP системах с целью снятия конкуренции за последний листовой блок индекса, т.к. благодаря переворачиванию значения две соседние записи индекса попадают в разные блоки индекса. Он не может использоваться для диапазонного поиска.
+ _функциональный индекс, индекс по вычисляемому полю (function-based index)_ — индекс, ключи которого хранят результат пользовательских функций. Функциональные индексы часто строятся для полей, значения которых проходят предварительную обработку перед сравнением в команде SQL. Например, при сравнении строковых данных без учета регистра символов часто используется функция UPPER. Кроме того, функциональный индекс может помочь реализовать любой другой отсутствующий тип индексов данной СУБД.
+ _первичный индекс_ — уникальный индекс по полю первичного ключа.
+ _вторичный индекс_ — индекс по другим полям (кроме поля первичного ключа).
+ _XML-индекс_ — вырезанное материализованное представление больших двоичных XML-объектов (BLOB) в столбце с типом данных xml.

__По механизму обновления__

+ _полностью перестраиваемый_ — при добавлении элемента заново перестраивается весь индекс.
+ _пополняемый (балансируемый)_ — при добавлении элементов индекс перестраивается частично (например, одна из ветви) и периодически балансируется.

__По покрытию индексируемого содержимого__

+ _полностью покрывающий (полный) индекс_ — покрывает всё содержимое индексируемого объекта.
+ _частичный индекс (partial index)_ — это индекс, построенный на части набора данных, удовлетворяющей определенному условию самого индекса. Данный индекс создан для уменьшения размера индекса.
+ _инкрементный (delta) индекс_ — индексируется малая часть данных(дельта), как правило, по истечении определённого времени. Используется при интенсивной записи. Например, полный индекс перестраивается раз в сутки, а дельта-индекс строится каждый час. По сути это частичный индекс по временной метке.
+ _индекс реального времени (real-time index)_ — особый вид инкрементного индекса, характеризующийся высокой скоростью построения. Предназначен для часто меняющихся данных.

__Индексы в кластерных системах__

+ _глобальный индекс_ — индекс по всему содержимому всех сегментов БД (shard).
+ _сегментный индекс_ — глобальный индекс по полю-сегментируемому ключу (shard key). Используется для быстрого определения сегмента, на котором хранятся данные в процессе маршрутизации запроса в кластере БД.
+ _локальный индекс_ —  индекс по содержимому только одного сегмента БД.

Описание некоторых типов индексов:

+ __Индексы B-дерева__ (B-tree index): это наиболее распространенный тип индексов, который используется в большинстве СУБД. Они хранятся в виде сбалансированного дерева и позволяют быстро искать данные в отсортированном порядке.
+ __Индексы хеш-таблицы__ (Hash index): используют хеш-функцию для быстрого поиска данных. Хеш-таблицы быстрее, чем индексы B-дерева, но они менее гибкие и не поддерживают сортировку.
+ __Индексы полнотекстового поиска__ (Full-text search index): используются для быстрого искания текстовых данных, таких как статьи, сообщения и другие текстовые документы. Они используют специальные алгоритмы и методы для поиска по тексту.
+ __Индексы пространственных данных__ (Spatial index): используются для поиска по геоданным, таким как координаты точек или границы полигонов. Они помогают определить, какие объекты расположены в пределах определенного географического района.
+ __Индексы кластеризации__ (Clustered index): используются для упорядочивания данных в таблице на основе значений индексированного столбца. Кластеризованный индекс является основой для хранения данных в таблице.
+ __Индексы, созданные пользователем__ (User-defined index): это индексы, созданные пользователем на основе специфических потребностей. Они могут быть созданы на одном или нескольких столбцах таблицы и могут быть приспособлены к конкретным запросам.

[к оглавлению](#Базы-данных)

## В чем отличие между кластерными и некластерными индексами? [Middle+]

Кластерный индекс (Clustered Index) и некластерный индекс (Non-Clustered Index) - это два основных типа индексов, используемых в реляционных базах данных.

Кластерный индекс упорядочивает данные в таблице на основе значений индексируемого столбца. Это означает, что строки в таблице хранятся физически в порядке значений индексированного столбца. В таблице может быть только один кластерный индекс, поскольку он определяет физический порядок данных в таблице.

Некластерный индекс, с другой стороны, не изменяет порядок строк в таблице. Он содержит отдельную структуру данных, в которой значения индексированных столбцов хранятся вместе со ссылками на соответствующие строки таблицы. В таблице может быть несколько некластерных индексов, которые позволяют быстро искать данные по нескольким столбцам.

Отличия между кластерными и некластерными индексами:

+ Физический порядок данных: Кластерный индекс упорядочивает данные в таблице на основе значений индексируемого столбца, тогда как некластерный индекс не меняет порядок строк в таблице.

+ Количество индексов: В таблице может быть только один кластерный индекс, тогда как может быть несколько некластерных индексов.

+ Скорость выполнения запросов: Кластерный индекс обеспечивает быстрый доступ к данным, если запрос использует значения, на которые производится кластеризация. Некластерный индекс обеспечивает быстрый доступ к данным, если запрос использует значения, на которые создан этот индекс.

+ Размер индекса: Кластерный индекс занимает меньше места на диске, чем некластерный индекс, потому что строки в таблице хранятся в порядке значений индексированного столбца.

+ Обновление данных: Обновление данных в кластеризованной таблице может занимать больше времени, чем в некластеризованной таблице, потому что данные должны быть переупорядочены в соответствии с новыми значениями индексированного столбца. Обновление данных в таблице с некластерными индексами может быть быстрее, потому что индекс не изменяет порядок строк в таблице.

[к оглавлению](#Базы-данных)

## Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений? [Middle+]

Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае оптимизация приведет к замедлению выборки.

Индексирование данных, имеющих небольшое количество возможных значений, может иметь смысл в зависимости от того, как эти данные будут использоваться в запросах.

Если эти данные не используются в условиях запроса, то индексирование их может быть бесполезным. Например, если столбец "Пол" в таблице имеет только два возможных значения: "мужской" или "женский", и этот столбец не используется в условиях запроса, то индексирование его не имеет смысла.

Однако, если эти данные используются в условиях запроса, то индексирование может значительно ускорить выполнение запросов. Например, если столбец "Страна" в таблице имеет небольшое количество возможных значений, но часто используется в условиях запросов, то индексирование этого столбца может ускорить выполнение запросов.

Также стоит учитывать, что размер индекса может быть меньше, если столбец имеет небольшое количество возможных значений. Это может означать, что индексирование таких данных не занимает много места на диске, что может быть выгодно с точки зрения производительности базы данных.

[к оглавлению](#Базы-данных)

## Когда полное сканирование набора данных выгоднее доступа по индексу?[Middle+]

Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из набора данных. Число блоков, которые надо при этом прочитать из набора зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее, и оно выбирается оптимизатором.

Таким образом, полное сканирование выбирается при слабой селективности предикатов запроса и/или слабой кластеризации данных, либо в случае очень маленьких наборов данных.

Полное сканирование набора данных (Full Table Scan) может быть выгоднее доступа по индексу в следующих случаях:

+ Когда количество строк в таблице невелико: Если таблица содержит небольшое количество строк, то полное сканирование может быть быстрее, чем доступ по индексу. Это связано с тем, что для выполнения доступа по индексу, база данных должна выполнить дополнительные операции, такие как поиск по индексу и обращение к соответствующей строке в таблице.

+ Когда запрашиваемые данные составляют большую часть таблицы: Если запрос требует большой части таблицы, то выполнение полного сканирования может быть быстрее, чем использование индекса. Это связано с тем, что для выполнения доступа по индексу, база данных должна обращаться к индексу и затем к таблице, чтобы извлечь необходимые данные, что может занять больше времени, чем выполнение полного сканирования.

+ Когда индекс нерелевантен запросу: Если индекс не релевантен запросу, то выполнение полного сканирования может быть быстрее. Например, если запрос запрашивает большую часть таблицы или если индекс находится на неактуальном столбце.

+ Когда данные не упорядочены: Если данные не упорядочены, то выполнение полного сканирования может быть быстрее, чем доступ по индексу. Это связано с тем, что для выполнения доступа по индексу, база данных должна отсортировать данные по индексу, что может занять больше времени, чем выполнение полного сканирования.

[к оглавлению](#Базы-данных)

## Что такое _«транзакция»_? [Junior]

__Транзакция__ - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в изменении данных, хранящихся в базе данных.

__Транзакция__ - это логически связанная последовательность операций с базой данных, которая должна быть выполнена целиком или не выполнена вовсе. В контексте базы данных транзакция представляет собой некоторый блок кода или набор команд, которые выполняются одновременно и либо все успешно завершаются, либо все откатываются.

[к оглавлению](#Базы-данных)

## Назовите основные свойства транзакции. [Junior]

__Атомарность (atomicity)__ гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. 

__Согласованность (consistency)__. Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных.

__Изолированность (isolation)__. Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.

__Долговечность (устойчивость, durability)__. Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.

[к оглавлению](#Базы-данных)

## Какие существуют уровни изолированности транзакций? [Middle+]

В порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными:

+ __Чтение неподтверждённых данных (грязное чтение) (read uncommitted, dirty read)__ — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. В этом уровне транзакция может читать данные, которые были изменены другой транзакцией, но еще не подтверждены (COMMIT). Также возможны фантомные чтения (__phantom reads__), когда транзакция может видеть новые строки, добавленные другой транзакцией, которые еще не были подтверждены. Этот уровень изоляции предоставляет максимальную скорость и конкуренцию между транзакциями, но при этом максимально нарушает изоляцию.
+ __Чтение подтверждённых данных (read committed)__ — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций. В этом уровне транзакция может читать только те данные, которые уже были подтверждены другими транзакциями. Этот уровень изоляции предотвращает чтение несуществующих строк и фантомных чтений.
+ __Повторяемость чтения (repeatable read, snapshot)__ — чтение всех изменений своей транзакции, любые изменения, внесённые параллельными транзакциями после начала своей, недоступны. В этом уровне транзакция может читать только те данные, которые уже были подтверждены другими транзакциями, и при этом также блокирует данные, которые будут изменены в рамках транзакции, чтобы избежать изменений, внесенных другими транзакциями в эти данные. Этот уровень изоляции предотвращает фантомные чтения и гарантирует, что данные не изменятся, пока транзакция выполняется.
+ __Упорядочиваемость (serializable)__ — результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают. В этом уровне транзакция блокирует все данные, которые будут использоваться в рамках транзакции, чтобы избежать изменений, внесенных другими транзакциями в эти данные. Этот уровень изоляции предоставляет максимальный уровень конкуренции между транзакциями, но может приводить к длительным блокировкам и снижению производительности.

[к оглавлению](#Базы-данных)

## Что такое фантомы (phantom reads)? [Middle+]

Фантомные чтения (phantom reads) - это аномалия, которая может возникнуть в транзакционных системах при одновременном выполнении нескольких транзакций, которые изменяют одни и те же данные.

Фантомное чтение происходит, когда одна транзакция читает некоторые строки из базы данных, затем другая транзакция вставляет или удаляет строки, которые соответствуют критериям поиска первой транзакции, и затем первая транзакция выполняет тот же запрос еще раз, но уже видит новые строки, которых не было в первый раз. Таким образом, первая транзакция получает неожиданный результат, который не соответствует ее первоначальному запросу, что может привести к ошибкам и непредсказуемому поведению системы.

## Какие проблемы могут возникать при параллельном доступе с использованием транзакций? [Middle+]

При параллельном выполнении транзакций возможны следующие проблемы:

+ __Потерянное обновление (lost update)__ — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;
+ __«Грязное» чтение (dirty read)__ — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);
+ __Неповторяющееся чтение (non-repeatable read)__ — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;
+ __Фантомное чтение (phantom reads)__ — одна транзакция в ходе своего выполнения несколько раз выбирает множество записей по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи или изменяет столбцы некоторых записей, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества записей. 
  Предположим, имеется две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:

| Транзакция 1                             | Транзакция 2              |
| ---------------------------------------- | ------------------------- |
|                                          | SELECT SUM(f2) FROM tbl1; |
| INSERT INTO tbl1 (f1,f2) VALUES (15,20); |                           |
| COMMIT;                                  |                           |
|                                          | SELECT SUM(f2) FROM tbl1; |

В транзакции 2 выполняется SQL-оператор, использующий все значения поля f2. Затем в транзакции 1 выполняется вставка новой строки, приводящая к тому, что повторное выполнение SQL-оператора в транзакции 2 выдаст другой результат. Такая ситуация называется чтением фантома (фантомным чтением). От неповторяющегося чтения оно отличается тем, что результат повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.

При параллельном доступе с использованием транзакций могут возникать следующие проблемы:

+ __Проблемы конкуренции__: При параллельном доступе нескольких транзакций к одним и тем же данным могут возникать проблемы конкуренции. Например, две транзакции могут попытаться одновременно изменить одну и ту же строку в таблице, что может привести к конфликту и блокировке одной из транзакций.

+ __Проблемы изоляции__: Если уровень изоляции транзакции недостаточно высок, то могут возникать проблемы с доступом к измененным или удаленным данным. Например, транзакция может попытаться прочитать данные, которые были изменены или удалены другой транзакцией, но еще не были подтверждены.

+ __Проблемы устойчивости__: При неожиданном сбое системы или компьютера могут возникнуть проблемы с устойчивостью транзакции. Например, если транзакция была только частично выполнена, то данные в базе могут оставаться несогласованными и стать непригодными для использования.

+ __Проблемы целостности__: При одновременном доступе нескольких транзакций могут возникать проблемы с нарушением ограничений целостности данных. Например, если две транзакции пытаются вставить строки с одинаковыми значениями первичного ключа, то может возникнуть ошибка ограничения уникальности.

Чтобы избежать этих проблем, необходимо правильно настроить параметры транзакций, выбирать подходящий уровень изоляции и обеспечивать устойчивость транзакций в случае сбоев. Также необходимо правильно проектировать базу данных и предусматривать ограничения целостности данных, чтобы предотвратить нарушения целостности при параллельном доступе к данным.

[к оглавлению](#Базы-данных)

# Источники

+ [Википедия](https://ru.wikipedia.org/wiki/)
+ [tokarchuk.ru](http://tokarchuk.ru/2012/08/indexes-classification/)
+ [Quizful](http://www.quizful.net/interview/sql/)

[Вопросы для собеседования](README.md)
