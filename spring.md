[Вопросы для собеседования](README.md)

# Spring

+ [Spring Core](#Spring-Core) [Junior]
+ [Spring MVC](#Spring-MVC) [Junior]
+ [Spring Validator](#Spring-Validator) [Junior]
+ [Spring Boot](#Spring-Boot) [Junior]
+ [Spring Security](#Spring-Security) [Junior]
+ [Spring REST](#Spring-REST) [Junior]
+ [JWT](#JWT) [Junior]

## Spring Core

## Что такое Spring Framework? 

__Spring Framework__ - Платформа приложений с открытым исходным кодом, написанная на Java, которая определяет структуру системы (приложения) и облегчает разработку системы и их интеграцию.
Фреймворк - это больше, чем просто библиотека (определяет структуру системы, предоставляет определенные паттерны разработки).

__Востребованность Spring__:
+ Один из самых популярных web-фреймворков в мире.
+ Самый популярный Java-фреймворк.
+ Java - один из самых популярных ЯП в мире. Spring обычно используется везде, где используется Java.
+ Очень востребован работодателями по всему миру.

Spring Framework состоит из множества компонентов => облегчает множество аспектов разработки приложений на Java.
Компоненты:
+ Контекст приложения (Application Context) и Внедрение зависимостей (Dependency Injection).
+ Удобный и эффективный доступ к БД (замена JDBC).
+ Компонент для разработки web-приложений на Java (Spring MVC).
+ Множество других полезных компонентов (spring.io).

## В чем преимущества Spring?
+ Spring является легким в использовании ресурсов, при этом базовая структура Spring весит всего 2 МБ памяти.
+ __Масштабируемость__: интерфейс управления транзакциями Spring может масштабироваться как до локальной транзакции в одной базе данных, так и до глобальных транзакций с помощью модуля JTA
+ __Обработка исключений__: Обработка исключений проста благодаря многочисленным ресурсам API для обработки исключений в каждом модуле.
+ __Многоуровневая архитектура__: Позволяет использовать нужные части программы и отказаться от остальных.
+ __Включено POJO__: Простое старое объектное программирование на Java обеспечивает непрерывную тестируемость и интеграцию.
+ __С открытым исходным кодом__: Бесплатно для всех и без блокировки поставщика.
+ __Инверсия управления (IOC)__: Достигается свободная связь через IOC, позволяя объектам передавать свои зависимости другим объектам, а не зависимым объектам.
+ __Аспектно-ориентированный (AOP)__: Spring поддерживает аспектно-ориентированное программирование, парадигму, которая отделяет бизнес-логику приложений от системных служб.

## Каковы различные компоненты приложения Spring?
Приложения Spring содержат пять компонентов:
+ __Интерфейс__: Определяет функции программы.
+ __Класс компонента__: Содержит свойства, методы настройки и получения для доступа к компоненту, а также определенные функции и т.д.
+ __Spring Аспектно-ориентированное программирование (AOP)__: Включает в себя сквозные функциональные возможности, которые не поддерживаются в объектно-ориентированном программировании.
+ __Файл конфигурации компонента__: Содержит информацию о классах, способах их настройки и определяет их взаимосвязи.
+ __Пользовательская программа__: Вызывает функции по всей программе

__Application Context & Dependency Injection__

Типичное Java приложение - это набор Java объектов, которые взаимодействуют друг с другом и ссылаются друг на друга.

![image](https://user-images.githubusercontent.com/116163780/236843731-63d77f43-3282-47bc-bed6-8c6b45f0dfc1.png)

Кргда Java приложение запускается, все необходимые Java объекты создаются и помещаются в оперативную память. В ходе работы приложения, объекты могут добавляться / удаляться. Также могут изменяться связи между объектами.
Большое количество объектов и связей между ними встречается в любом более-менее сложном Java приложении. Spring помогает нам в работе с множеством объектов.

Существуют некоторые проблемы при создании приложений, например, нужно что бы конкретный объект создавался только один раз (пример Database). Можно решить это без Spring с помощью паттерна Singleton. но для этого требуется дополнительный код. Еще одна проблема, что нужно внедрять ссылку на этот единственный объект (Database) во все остальные классы, выстроить иерархию. Можно сделать вручную, но это очень сложно и запутанно.

![image](https://user-images.githubusercontent.com/116163780/236846479-0ff13f4b-d6c6-4174-8d16-828ff6c7a490.png)

![image](https://user-images.githubusercontent.com/116163780/236848438-38ff8c7c-f143-4fcd-83f3-62bd231b815d.png)

Spring Framework дает возможность удобного и эффективного доступа к БД, предоставляет для этого множество инструментов для взаимодействия с БД.
JDBC - примитивный и неудобный способ взаимодествия с БД. Он не подходит для сложных приложений, слишком низкоуровневый.

__Spring MVC__ - компонент Spring Framework, который позволяет создавать Web - приложения.
Огромное количество Web - приложений в интернете работают на Spring MVC.
Помимо этого, Spring MVC часто используется в качестве backend - API для мобильных приложений.

## Что такое файл конфигурации для Spring?
Файл конфигурации для Spring представляет собой XML-файл, содержащий информацию о классе для проекта. Они описывают конфигурацию каждого класса, то, как они представлены другим классам, и зависимости во всей программе.

## Наполнение конфигурационного файла Spring 
Конфигурационный файл Spring должен называться __applicationContext.xml__

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans  xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <bean id="testBean"
        class="ru.kirillova.springcourse.TestBean">
        <constructor-arg value="Neil"/>
    </bean>
</beans>
```

Это стандартная конфигурация, которая позволяет использовать Spring Framework.
В теге `<bean>` создается новый бин, у него есть `id` - уникальный идентификатор объекта, `class`- путь к классу, бин которого мы хотим создать, `TestBean` - название класса, бин которого мы хотим создать, `"ru.kirillova.springcourse.TestBean"` - соответственно сам путь до класса, ` <constructor-arg>` -  передаем параметры для конструктора для создания бина.

## Inversion of Control (IoC)
__Инверсия управления__

![image](https://user-images.githubusercontent.com/116163780/237034903-2a9d2e96-d5e7-442c-97fb-ca87a6ed1655.png)

![image](https://user-images.githubusercontent.com/116163780/237035316-c8af838e-5975-4fc8-b514-107f95413f0e.png)

![image](https://user-images.githubusercontent.com/116163780/237035955-ccc47398-0419-42b7-801b-f827a805a8a8.png)

## Что такое Spring IoK контейнер?
Контейнер IoC создает, настраивает и соединяет объекты, одновременно управляя их жизненным циклом. Контейнер получает инструкции по этим областям из метаданных конфигурации, предоставленных пользователем.

## Каковы типы IoK?
+ __Контейнер BeanFactory__: Этот заводской класс содержит предварительно упакованную коллекцию компонентов, которые создаются при вызове клиентами. Это самый простой контейнер для поддержки DI.
+ __Контейнер ApplicationContext__: Построенный поверх контейнера BeanFactory, этот контейнер обеспечивает дополнительные функциональные возможности, ориентированные на предприятие. Например, контейнеры ApplicationContext предоставляют возможность разрешать текстовые сообщения и публиковать события приложения.

## Что такое Аспектно-ориентированное программирование (AOП)?
AOП-это метод программирования, который позволяет программистам модулировать поведение, используемое в типичных подразделениях ответственности, используемых в объектно-ориентированном программировании. Основная конструкция аспектов AOП – это поведение, применимое к разным классам. Извлечение этих моделей поведения из отдельных компонентов в аспекты позволяет легко использовать их повторно.

## Что такое Bean?
Это объекты, созданные из метаданных конфигурации при их передаче в контейнер IOC. Они составляют основу всех Spring. Контейнер IOC создает экземпляры, настраивает, подключает и управляет каждым компонентом.
Это просто Java объект. Когда Java объекты создаются с помощью Spring'а они называются бинами (beans).
Бины создаются из Java классов (так же, как и обычные объекты).

```xml
<bean id="testBean"
        class="ru.kirillova.springcourse.TestBean">
        <constructor-arg value="Neil"/>
</bean>
```

![image](https://user-images.githubusercontent.com/116163780/237036918-4454190c-26e3-4a75-a466-43ba8da743d7.png)

`MusicPlayer` слабо зависит от интерфейса `Music`. В методе `playMusic()` видим, что `MusicPlayer` сам создает свои зависимости, даже если будем использовать Spring Framework, мы будем сами обращаться к application context'у и будем сами извлекать из него созданный бин.

![image](https://user-images.githubusercontent.com/116163780/237039107-8ec81f02-9819-4e60-a5c9-ac149ebb7d22.png)

__Inversion of Control__ - это такой архитектурный подход, когда сущность не сама создает свои зависимости, а когда зависимости для этой сущности поставляются извне.

![image](https://user-images.githubusercontent.com/116163780/237040068-24a936a8-f8c2-4318-a804-abe094fd2e32.png)

![image](https://user-images.githubusercontent.com/116163780/237040271-ecc4e3e0-ee8d-450e-af6d-7541e0ae2536.png)

![image](https://user-images.githubusercontent.com/116163780/237040521-49e6c6dd-748b-43d1-b544-0a8417eb5442.png)

Решние этой проблемы с помощью внедрения зависимостей (Dependency Injection) с помощью Spring Framework будет рассмотрена далее.


__Смотри код в папке `spring-app1` или уроки №5,6, показано на практике внедрение зависимостей и создание бинов на примере `MusicPlayer`__


## Какие есть способы конфигурации Spring Framework?
+ XML файл когфигурации (старый способ, но многие существующие приложения до сих пор его используют, будут рассмотрены несколько примеров далее с его использованием).
+ Java аннотации и немного XML (современный способ).
+ Вся конфигурация на Java коде (современный способ).

## Как создать ApplicationContext в программе Java?
В независимой Java программе ApplicationContext можно создать следующим образом:
+ __AnnotationConfigApplicationContext__: при использовании Spring в качестве автономного приложения можно создать, инициализировать контейнер с помощью аннотаций.
+ __ClassPathXmlApplicationContext__: второй подход использует xml файл, в котором задаются необходимые настройки, а затем используем класс для загрузки файла и получения объекта контейнера.
+ __FileSystemXmlApplicationContext__: аналогичен варианту с xml, но с возможностью загрузки файла конфигурации из любого места файловой системы.

## Каковы общие реализации ApplicationContext?
Тремя наиболее популярными контейнерами являются:
+ __AnnotationConfigApplicationContext__: Эта реализация позволяет создавать ApplicationContext на основе аннотаций конфигурации. Вы можете указать классы конфигурации, содержащие аннотации, такие как `@Configuration` и `@Bean`, и ApplicationContext создаст бины на основе этих аннотаций.
+ __FileSystemXmlApplicationContext__: Заставляет конструктор загружать определения компонентов из файла конфигурации XML. На него должен быть указан полный путь к файлу.
+ __ClassPathXmlApplicationContext__: Этот контейнер выполняет то же самое, что и выше, но не требует полного пути к файлу. Вместо этого вы устанавливаете свойство CLASSPATH и позволяете контейнеру находить XML по этому CLASSPATH.
+ __WebXmlApplicationContext__: Загружает все определения компонентов в веб-приложение из XML-файла.
+ __AnnotationConfigWebApplicationContext__: Эта реализация предназначена для веб-приложений и позволяет создавать ApplicationContext на основе аннотаций конфигурации. Она автоматически обнаруживает классы конфигурации, используемые в вашем веб-приложении, и создает бины на основе этих аннотаций.

## В чем разница между BeanFactory и ApplicationContext?
__BeanFactory__ – это базовый, компактный контейнер с ограниченной функциональностью. Его лучше всего использовать для простых задач или при использовании машин с низким ресурсом.
__ApplicationContext__ – это расширенный, более интенсивный контейнер с расширенным интерфейсом и дополнительными возможностями, такими как AOP. Этот контейнер лучше всего использовать, когда вам требуется больше функциональности, чем на заводе Bean, и у вас достаточно ресурсов, доступных на машине.

## Типичные шаги в работе со Spring
+ Создаем Java классы (будущие бины)
+ Создаем и связываем бины с помощью Spring (аннотации, XML или Java код)
+ При использовании, все объекты (бины) берутся из контейнера Spring

## Dependency Ijection
__Внедрение зависимостей (DI)__ - это концепция, которая определяет, как должно быть связано несколько классов. Это один из примеров Инверсии контроля. Вам не нужно явно подключать службы и компоненты в коде при использовании внедрения зависимостей. Вместо этого вы описываете службы, необходимые каждому компоненту, в файле конфигурации XML и разрешаете контейнеру IOC автоматически подключать их.
К достоинствам применения DI можно отнести:
+ Сокращение объема связующего кода, который должен быть написан для связывания вместе различных компонентов приложения. Зачастую этот код очень прост — при создании зависимости должен создаваться новый экземпляр соответствующего объекта.
+ Упрощенная конфигурация приложения. Для конфигурирования классов, которые могут быть внедрены в другие классы, можно использовать аннотации или XML-файлы.
+ Возможность управления общими зависимостями в единственном репозитории (в Spring есть возможность хранить эту информацию в XML-файлах или Java классах), что существенно упрощает управление зависимостями и снижает количество возможных ошибок.
+ Улучшенная возможность тестирования. Когда классы проектируются для DI, становится возможной простая замена зависимостей. Это особенно полезно при тестировании приложения.
+ Стимулирование качественных проектных решений для приложений. Вообще говоря, проектирование для DI означает проектирование с использованием интерфейсов. Используя Spring, вы получаете в свое распоряжение целый ряд средств DI и можете сосредоточиться на построении логики приложения, а не на поддерживающей DI платформе.

## Способы внедрения зависимостей
+ Через конструктор
+ Через setter
+ Можно внедрять ссылки или простые значения
+ Можно внедрять значения из внешнего файла
+ Есть множество конфигураций того, как внедрять (scope, init-method, destroy-method, factory method и т.д.)
+ Можно внедрять через XML, Java-аннотации или Java код
+ Процесс внедрения можно автоматизировать (Autowiring)

![image](https://user-images.githubusercontent.com/116163780/237057848-fd98f103-372d-4c97-97d7-7f1ac870c59d.png)

![image](https://user-images.githubusercontent.com/116163780/237058647-aa66855d-9e79-4d5d-bace-ca69530b75d3.png)

![image](https://user-images.githubusercontent.com/116163780/237059674-d64108fd-306a-4e25-9efb-9a726126303d.png)

## Что такое scope?
Scope задает то, как Spring будет создавать ваши бины.
Есть такой scope, который называется __Singleton__, он используется по умолчанию.
Singleton - это паттерн программирования.

Если не указывать scope, то по умолчанию Singleton:

```xml
<bean id="musicBean"
	class="ru.kirillova.springcourse.ClassicalMusic">
</bean>
```

+ По умолчанию создается один объект (он создается до вызова метода `getBean()`).
+ При всех вызовах `getBean()` возвращается ссылка на один и тот же единственный объект.

Scope Singleton чаще всего используется тогда, когда у нашего бина нет изменяемых состояний (stateless).
Потому что если будем изменять состояние у Singleton бина, столкнемся с проблемой.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/ba2e9681-33c3-46b0-a28a-eec7a8349d14)

Здесь видим, что среда разработки говорит, что Singleton используется по умолчанию, и указывать его явно нет смысла.

Еще один scope, который называется __Prototype__, каждый раз создает новый объект при вызове `getBean()`. Используется, когда у бина есть изменяемые состояния (stateful).

Другие scope'ы , такие как request, session, flobal-session, будут изучены в разделе Spring MVC.

## Жизненный цикл бина (Bean Lifecycle)
смотри код в папке C:\IntelliJ IDEA workspace\SpringCourse\Lesson8.InitDestroyAndFactory

## Каковы этапы жизненного цикла компонента?
Жизненный цикл компонента состоит из семи этапов:
+ __Создать экземпляр__: Компонент создается контейнером Spring с использованием определения компонента, найденного в файле конфигурации XML.
+ __Заполнение свойств__: Spring заполняет все определенные свойства из XML-файла с помощью внедрения зависимостей.
+ __Установить имя компонента__: Spring передает идентификатор компонента методу `setBeanName()`, если компонент использует интерфейс `BeanNameAware`.
+ __Установить baen factory__: Spring передает beanfactory методу `setBeanFactory()`, если компонент настроен на использование интерфейса `BeanFactoryAware`.
+ __Предварительная инициализация__: Spring вызывает любые `BeanPostProcessors`, связанные с компонентом, с помощью метода `postProcessorBeforeInitialization()`.
+ __Инициализация__: Затем инициализируется компонент. Выполняется любой специальный процесс инициализации, указанный в методе инициализации.
+ __Постинициализация__: Вызываются все определенные методы `postProcessAfterInitialization()`. Теперь bean завершен. Компоненты, реализующие `DisposableBean`, будут удалены с помощью функции `destroy()` после завершения их работы.

## Является ли Spring бин потокобезопасным?
По умолчанию бин задается как синглтон в Spring. Таким образом все публичные  переменные класса могут быть изменены одновременно из разных мест. Так что — нет, не является. Однако поменяв область действия бина на request, prototype, session он станет потокобезопасным, но это скажется на производительности.

## Объясните внутреннюю часть bean в Spring
Внутренний компонент используется как свойство другого компонента. Внутренние компоненты могут быть определены в XML-файле конфигурации либо в элементах `<property>`, либо `<constructor-arg>`. Все внутренние компоненты всегда имеют область действия как `prototype` и не имеют идентификаторов.

## Что такое автоматическая проводка bean?
Это функция Spring, которая позволяет контейнеру Spring автоматически устанавливать отношения зависимостей между сотрудничающими компонентами, просматривая BeanFactory. Автоматическая проводка может быть настроена для определения этих отношений с использованием имен компонентов, типов или даже конструкторов классов.

## Специальные методы бинов
init-method, destroy-method, factory method

![image](https://github.com/Slimercorp/java-interview/assets/116163780/31f09c3b-504c-4b64-bf56-7bb96a459243)

__init-method__

Это метод, который запускается в ходе инициализации бина. Используется для инициализации ресурсов, обращения к внешним файлам, запуска БД.

__destroy-method__

Этот метод, который запускается в ходе уничтожения бина (при завершении приложения). В этом методе обычно происходит очищение ресурсов, закрытие потоков ввода-выводы, закрытие доступа к БД.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/08046928-642f-4c1b-8d9d-1311e034e79c)

```java
public class ClassicalMusic implements Music {
    private ClassicalMusic() {}

    public static ClassicalMusic getClassicalMusic() {
        return new ClassicalMusic();
    }

    public void doMyInit() {
        System.out.println("Doing my initialization");
    }

    public void doMyDestroy() {
        System.out.println("Doing my destruction");
    }

    @Override
    public String getSong() {
        return "Hungarian Rhapsody";
    }
}
```

__Тонкости init и destroy методов:__
+ Модификатор доступа - может быть любой у обоих методов (public, protected, private).
+ Тип возвращаемого значения - может быть любой, но чаще всего используется void, т.к. нет возможности получить возвращаемое значение.
+ Название метода - может быть любое.
+ Аргументы метода - эти методы не должны принимать на вход какие-либо аргументы.

Для бинов со scope "prototype" Spring не вызывает destroy мотод.
Spring не берет на себя полный жизненный цикл бинов со scope "prototype". Spring отдает prototype бины клиенту и больше о них не заботится (в отличие от singleton бинов).

__factory method__

Фабричный метод (англ. Factory Method) - это паттерн программирования.
Если объекты класса создаются фабричным методом, то можно определить factory method.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/0719c747-c9d8-408e-80c7-b51d9ef039bc)

## Как все работает
+ У нас есть XML файл, там мы прописываем бины
+ Поднимаем контекст
+ Приходит XmlBeanDefinitionReader, считывает с этого xml все декларации бинов и кладет их в map BeanDefinitions : id бина - декларация бина. В декларацию входит : из какого класса нужно создавать бин, есть ли init-method, если есть, то как он называется, какие properties у этого бина, и все остальные подробности бина, которые мы прописываем в xml.
+ После того как все map BeanDefinitions созданы, BeanFactory начинат по ним работать, создает из наших классов объекты, и все бины складывает в контейнер IoC Container. Если бин Singleton, то умолчанию он создается как только мы поднимаем контекст и сразу складывается в контейнер, а все Prototype создаются только тогда, когда они нужны, т.е. из какого-то участка кода его запросили, Spring его создал, настроил, отдал и забыл про него. __Это важно__ , т.к. если мы прописываем destroy-method для бина, то для Singleton он будет работать, потому что в тот момент когда контекст закрывается Spring проходит по всем бинам, которые хранятся в контейнере, а это только Singleton, находит их destroy-method'ы и запускает их; а Prototype бины Spring нигде не хранит, соответственно для Prototype бинов destroy-method никогда не работает.
+ Из этого контейнера выходят полностью настроенные бины.

## Интерфейс BeanPostProcessor
+ Позволяет настраивать наши бины до того, как они попадают в контейнер.
+ У этого интерфейса 2 метода :
    + Object postProcessBeforeInitialization(Object bean, String beanName) - вызывается до init-method'а
    + Object postProcessAfterInitialization(Object bean, String beanName)- вызывается после init-method'а
+ А между ними вызывается init-method:
    + init-method - для xml файла
    + afterPropertieSet - если работаем на Spring2, который не знает про аннотации - устаревший метод, сейчас так не делают.
    + `@PostConstruct` - для работы с аннотациями

## ApplicationListener
Умеет слушать контекст Spring'а, все ивенты, которые с ним происходят:
+ `ContextStartedEvent` - означает, что контекст начал свое построение.
+ `ContextStoppedEvent`
+ `ContextRefreshedEvent`
+ `ContextClosedEvent`
Из любого ивента можно вытащить контекст.

## Что такое Java аннотация?
__Java аннотация__ - это специальный тип комментариев в вашем коде с помощью которых можно:
+ Передавать какие-либо инструкции для Java компилятора (пример: @Override).
+ Передавать какие-либо инструкции для анализаторов исходного кода.
+ Передавать метаданные, которые могут быть использованы либо вашим Java приложением(с помощью рефлексии), либо другими приложениями или фреймворками (привет: Spring Framework).

![image](https://github.com/Slimercorp/java-interview/assets/116163780/fcb9649a-e134-4ba7-badd-969eda6fbbd2)

## Аннотация @Component
+ Помечаем ей класс, если хотим, чтобы Spring создал бин из этого класса.
+ Именно эту аннотацию Spring ищет, когда сканирует все ваши классы.
+ Можно указать `id` для создаваемого бина, можно не указывать (тогда будет название `название_класса_с_маленькой_буквы`).

При использовании аннотаций, ручное создание бинов в xml файле уже не актуально, нужно всего лишь сказать Spring чтобы он отсканировал все компоненты, включает эту операцию следующуя строка:

```xml
<context:component-scan base-package="ru.kirillova.springcourse" />
```

Теперь при запуске приложения Spring отсканирует все классы в пакете `springcourse` и создаст бины классов, помеченных аннотацией `@Component`.
Сканирует все классы `ClassPathDefinitionScanner` и ищет все бины, которые аннотированы `@Component`. Этот сканер не является ни BeanPostProcessor'ом, ни BeanFactoryPostProcessor'ом. Он является `ResourceLoaderAware` - подгружает дополнительные ресрсы.

## Кто обрабатывает JavaConfig?
+ ConfigurationClassPostProcessor (особый BeanFactoryPostProcessor)
+ Его регистрирует AnnotationConfigApplicationContext
+ Он создает бин-дифинишны по @Bean
+ А так же относится к:
    + @Import
    + @ImportResource
    + @ComponentScan 

## Аннотация @Autowired
Эта аннотация осущществляет внедрение зависимостей.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/17b78544-93fc-415d-979d-a8c6b64a5685)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/e8872f97-ef79-408a-a318-2521628a10c1)

Мы можем внедрять бины указывая конкретный класс, или какой-то интерфейс:

![image](https://github.com/Slimercorp/java-interview/assets/116163780/6b42a6e2-a034-409c-ae79-39eee193dcc9)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/81dc0195-cbe8-40af-9325-d877c0df8e45)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/df84209f-2f15-4814-9757-0600fb776e62)

## Аннотация @Qualifier
Решает проблему неоднозначности, когда для внедрения подходят несколько бинов.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/c552d69e-dbcf-4094-9640-6f8e21411cf2)

Эту аннотацию можно использовать на :
+ Конструкторах
+ Сеттерах
+ Полях

![image](https://github.com/Slimercorp/java-interview/assets/116163780/63d80334-b6e6-4e47-8279-4218283e9175)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/f2b55a1e-7488-4bf3-ac30-0a057e42fddb)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/99751ac7-a986-4c53-8603-aba18ab3ff03)


## Аннотация @Value

![image](https://github.com/Slimercorp/java-interview/assets/116163780/65b54e68-418e-408d-8388-c5bc72b2da3c)

Тоже самое можно делать с помощью `@Value`.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/22f1be1d-5f90-40a5-906b-09ffb07e75ed)

Первые два шага идентичны, но внедрение осуществляем с помощью `@Value`. Аннотируем (помечаем) поля, в аргументы посталяем название ключа. Значение, которое лежит по этому ключу будет внедрено в соответствующее поле.

## Аннотация @Scope

![image](https://github.com/Slimercorp/java-interview/assets/116163780/01867ddd-13f6-4341-8fd3-6e202a5c3aa4)

Конфигурацию области видимости мы тоже можем настроить с помощью аннотаций - для этого и существует @Scope.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/8b00b9bb-e08f-4695-a07b-a955c6d220fb)

## Какие вы знаете различные scope у Spring Bean?
Spring поддерживает пять областей bean
+ __singleton__: ограничивает определение компонента одним экземпляром для каждого контейнера Spring IoC. Может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если не указано другое. Следует осторожно использовать публичные свойства класса, т.к. они не будут потокобезопасными.
+ __prototype__: создается новый экземпляр при каждом запросе. Охватывает один компонент для включения любого количества экземпляров.
+ __request__: аналогичен prototype, но название служит пояснением к использованию бина в веб приложении. Создается новый экземпляр при каждом HTTP request.
+ __session__: новый бин создается в контейнере при каждой новой HTTP сессии.
+ __global-session__: используется для создания глобальных бинов на уровне сессии для Portlet  приложений. Расширяет определение компонента до глобального HTTP.

## Аннотации @PostConstruct и @PreDestroy
Есть два метода из жизненного цикла бина - init-method и destroy-method. В Spring аннотации `@PostConstruct` и `@PreDestroy` делают тоже самое. 

![image](https://github.com/Slimercorp/java-interview/assets/116163780/104d665f-253b-4a54-a976-203b708abf85)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/6681706a-1572-46bb-9b61-bc88abe10684)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/d0e885b7-4750-4cd3-a92e-8888f0eae294)

## Spring конфигурация с помощью Java кода

![image](https://github.com/Slimercorp/java-interview/assets/116163780/93c651f8-ddaf-4f67-b938-ebc50453be8a)

## Аннотация @Configuration

![image](https://github.com/Slimercorp/java-interview/assets/116163780/ce103b2c-a692-48d3-a24e-59c22c15631d)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/e7e92b79-ac21-4fde-b271-ff5970e33e8d)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/690bbbd5-10cb-468d-ac04-147f0446a734)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/7360c04f-3668-4678-ae75-61e4463c1546)

Раньше использовали  класс `ClassPathXmlApplicationContext` и указывали ему путь до конфигурационного xml файла. Теперь используем другой класс `AnnotationConfigApplicationContext`, ему на вход передаем конфигурационный класс и получаем доступ к контексту, из которого впоследствии можем получать бины.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/13ab6db6-8a8d-4db8-a9de-e0888b222ba0)

__@Bean__

![image](https://github.com/Slimercorp/java-interview/assets/116163780/45adc3af-2b19-46c5-b213-2ab548e4fb49)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/d7656935-1399-40d3-bb1e-231daec8bc77)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/36ac88d1-7c79-46f2-97b0-b4620bd26b40)

@PropertySource указывает путь до файла с нашими входными значениями.





## Spring MVC
__Spring MVC__ - это один из компонентов Spring Framework, который позволяет разрабатывать web приложения на Java.
Spring MVC предполагает разработку web приложений с использованием архитектуры Model - View - Controller.
Разрабатывая web приложения с помощью Spring MVC, мы можем использовать  все, что дает нам Spring Core - бины, DI, и так далее.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/3b5a29f9-980c-454e-bd21-0aad40d370b1)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/9f53d6d7-ef29-46b2-929b-b4c1c24ebaa6)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/a8c5eced-f644-4892-b711-32e0c90a5169)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/9480ac94-ca77-4163-8ad9-2e852d87201a)

Controller - это обычный Java класс, помечается аннотацией @Controller

![image](https://github.com/Slimercorp/java-interview/assets/116163780/9f88a82c-290b-4b99-814a-2adeeace9528)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/b317eaeb-006c-4f42-b8c2-bc562a482860)


Сервер (в нашем случае Apache Tomcat) считывает содержимое файла web.xml. То есть в этом файле мы можем прописать настройки для нашего сервера.

`DispatcherServlet` - класс для создания dispatcher servlet.

`@GetMapping` над методов в контроллере указывает какой url будет приходить в этот метод контроллера.
Пример: `@GetMapping("/hello-world")`.

## Конфигурация Spring MVC приложения:
+ web.xml и applicationContext.xml
    + web.xml считывается сервером Apache Tomcat, конфигурирует DispatcherServlet.
    + applicationContext.xml - конфигурация Spring приложения (бины, component scan, настройка Thymeleaf)
+ Java код


![image](https://github.com/Slimercorp/java-interview/assets/116163780/dfe00beb-6e74-4f7a-9eb7-32494c0ccfdb)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/1776299c-00af-430f-8f1f-f6d236edcd8e)

Конфигурационный файл Spring (Java класс) помечается аннотациями:
+ @Configuration
+ @ComponentScan - принимает в аргументы путь до пакета, в котором лежат компоненты
+ @EnabeWebMVC - т.к. теперь MVC приложение, эта анноотация равноценна тэгу `<mvc:annotation-driven/>` в  applicationContext.xml

Так же мы можем реализовать интерфейс WebMvcConfigurer, если мы хотим настроить Spring MVC под себя, например когда мы хотим использовать вмест стандартного шаблонизатора щаблонизатор Thymeleaf. Этот интерфейс обязывает реализовать метод `configererViewResolvers()` , в котором мы указываем необходимый шаблонизатор.

Так же с помощью Spring и @Autowired внедряем ApplicationContext.
Создаем бины, которые относятся к Thymeleaf.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/e35421d5-57bb-4391-bc90-e424be498886)

## Контроллеры

![image](https://github.com/Slimercorp/java-interview/assets/116163780/87c246da-b9ce-4039-967c-33227874a0e2)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/ad2f8a6f-5aa4-4fca-83b0-63b2e97d1ec2)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/7dc7b497-88ba-4b8c-8c8a-046e6fa55db5)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/13e882ff-1071-4a9f-b068-6c31ddb395b7)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/f8c5d388-1237-4aac-b8b0-ca385df894be)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/3f6cd16e-9050-4ba1-b854-2bc67fbe9f17)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/95cb8018-185c-4b8e-a19b-71030f2371a9)

Примечание:
1. При каждом запросе на этот метод контроллера в параметре `request` будет лежать объект, который представляет собой http запрос. Из этого http запроса с помощью вызова метода `getParameter()` и параметром этого метода, который равен названию ключа, мы можем получить значение параметра из GET запроса.
2. @RequestParam используется в методах контроллера, применяется к аргументам метода, принимает себе в аргументы название ключа того параметра, который ожидаем в URL. Spring сам возьмет этот параметр из URL и сам положит его в аргумет метода `name`. В отличии от `HttpServletRequest`, который при GET запросе кладет в параметны null, @RequestParam при запросе без параметров выдает ошибку.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/2cfcc7ff-f80c-443b-ae21-bc07ac595d7e)

что бы избежать ошибки при запросе без параметров, можно использовать такую конструкцию :

![image](https://github.com/Slimercorp/java-interview/assets/116163780/bac74b04-b7be-4863-9911-9e5453f5e810)

`required = false` означает, что если мы передаем праваметры в запросе, то они внедряются в переменные аргумента, если же не передаем параметры в URL, то в этих переменнах будет лежать null.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/c35475a8-b3ae-4f3d-80c1-37ef060b7b1f)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/5e9e455e-f8dd-4415-bcc9-0cb0050351b5)

метод `addAttribute()` - специальный метод, с помощью которого мы можем положить в модель пару ключ-значение, эта модель будет отправлена на представление, где с помощью шаблонизатора мы сможем получить значения по ключу.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/5cd8e8f3-bf85-4c84-a0fa-68b611f9e62f)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/5dd9fd09-695b-41d3-a98c-ba9d9dd32b71)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/df1aa464-75f8-4a89-9e0d-8bc8528a5067)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/80ad2757-bc47-40ab-9291-c00417616864)

Это URL по стандартам. Хоть сущность называется в единственном числе - `Post`, но при запросе GET мы получаем все все записи для этой сущности, поэтому URL во множественном числе - `/posts`.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/b0767475-ce5f-4013-8e2a-c97331e7a6cc)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/8130d5c5-cc15-4e79-ac78-30762659a5aa)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/5d8e5191-75c2-475d-9290-263531044df9)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/2fbf0b75-fb1b-4bf5-b33f-bf697be77fe5)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/b0088879-a8bc-458e-8b12-d04fd1812a62)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/5ec8f913-7b1d-4281-9c10-1cfdff2f6e67)

`{id}` означает, что в эти скобки при запуске мы сможем поместить любое число и оно поместится в аргументы метода
`@PathVariable` - извлекает значение из URL, в этом примере id из запроса поместится в аргументы метода

![image](https://github.com/Slimercorp/java-interview/assets/116163780/8a5e678a-f1d0-411d-960b-29ec175642ff)

У формы есть атрибуты `method` и `action`.
В `method` пиется тот http метод, который будет использоваться при отправки этой формы. В `action` пишется адрес, на который будут отправляться данные с этой формы. В данном случае, если мы нажмем `Add Person`, то данные будут отправлены методом `POST` на адрес `/people`.
Тег `<label>` дает понять пользователю что вводить в это поле, т.е. помечают поля, что именно надо вводить (Name, Surname, Email).
Тег `<input/>` создает поле для ввода.
`type="text"` - говорит, что поле будет текстовым.
`type="submit"` - говорит, что это кнопка и при нажатии на нее, все данные будут отправлены.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/9eaf05be-f5c9-4a40-ba12-d72d8318965d)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/89012db5-f8a0-40e1-ac92-e358eeb35de6)

HTML формы в Thymeleaf очень похожи на обычные HTML формы, но есть свои дополнительные функции:
+ HTML формы в Thymeleaf принимают на вход объект, для которого эта форма создана, т.е.  если мы хотим создать форму для человека (просто пример), мы должны в контроллере, который будет отдавать шаблон с этой формы, в модель поместить нового пустого человека, и в шаблоне мы должны получать доступ к этому объекту класса `Person`, у которого не назначены значения полей.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/f36444f0-6b06-4df7-8aa2-1f29853f2a0b)

`@ModelAttribute` работает по разному в зависимости от того, что она аннотирует.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/cdaf9686-92bb-4b7d-b10b-97b5a4ce00ef)

В данном случае в каждом методе текущего контроллера мы хотим добавить пару ключ-значение, т.е. в каждой моделе в методе `index`, в методе `show` и в методе `newPerson` по умолчанию была пара ключ-значение  с ключом = "headerMessage" и значением = "Welcome to our website!".

![image](https://github.com/Slimercorp/java-interview/assets/116163780/2c6889a3-018e-4861-9f31-69f44bbed2d1)

![image](https://github.com/Slimercorp/java-interview/assets/116163780/d117e8a0-4f3d-4c37-b5c8-77423209a76c)

Все те вещи, которые в первом случае делаются вручную (первый блок кода) : создание нового объекта, добавление значений этой объекту с помощью сеттеров, добавление созданного объекта в модель.
Все эти вещи берет на себя `@ModelAttribute`, которая аннотирует аргумент метода. Т.е. отправив POST запрос на этот метод контроллера, в аргументе `Person person` уже будет лежать объект класса `Person` с полями, которые были заданы значаниями из html формы. И этот объект класса `Person` уже будет помещен в модель.

![image](https://github.com/Slimercorp/java-interview/assets/116163780/8bb5e8cb-da31-400c-a797-15dcf736c0d3)





















## Spring Validator

## Spring Boot

## Spring Security

## Spring REST

## JWT












