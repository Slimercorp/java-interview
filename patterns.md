[Вопросы для собеседования](README.md)

# Шаблоны проектирования

+ [Что такое _«паттерн проектирования»_?](#Что-такое-паттерн-проектирования)
+ [Назовите основные характеристики шаблонов.](#Назовите-основные-характеристики-шаблонов)
+ [Типы шаблонов проектирования.](#Типы-шаблонов-проектирования)
+ [Приведите примеры основных шаблонов проектирования.](#Приведите-примеры-основных-шаблонов-проектирования)
+ [Приведите примеры порождающих шаблонов проектирования.](#Приведите-примеры-порождающих-шаблонов-проектирования)
+ [Приведите примеры структурных шаблонов проектирования.](#Приведите-примеры-структурных-шаблонов-проектирования) 
+ [Приведите примеры поведенческих шаблонов проектирования.](#Приведите-примеры-поведенческих-шаблонов-проектирования) 
+ [Что такое _«антипаттерн»_? Какие антипаттерны вы знаете?](#Что-такое-антипаттерн-Какие-антипаттерны-вы-знаете) 
+ [Что такое _Dependency Injection_?](#Что-такое-dependency-injection) 

## Что такое _«паттерн проектирования»_?

__Паттерн (шаблон) проектирования (design pattern)__ — это проверенное и готовое к использованию решение. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее - он не зависит от языка программирования, не является законченным образцом, который может быть прямо преобразован в код и может быть реализован по-разному в разных языках программирования.
Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.
Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.
Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его реализации.

Плюсы использования шаблонов:

+ снижение сложности разработки за счёт готовых абстракций для решения целого класса проблем.
+ облегчение коммуникации между разработчиками, позволяя ссылаться на известные шаблоны.
+ унификация деталей решений: модулей и элементов проекта.
+ возможность отыскав удачное решение, пользоваться им снова и снова.
+ помощь в выборе выбрать наиболее подходящего варианта проектирования.

Минусы:

+ слепое следование некоторому выбранному шаблону может привести к усложнению программы.
+ желание попробовать некоторый шаблон в деле без особых на то оснований.

[к оглавлению](#Шаблоны-проектирования)

## Из чего состоит паттерн?
Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:
+ проблема, которую решает паттерн;
+ мотивации к решению проблемы способом, который предлагает паттерн;
+ структуры классов, составляющих решение;
+ примера на одном из языков программирования;
+ особенностей реализации в различных контекстах;
+ связей с другими паттернами.
Такой формализм в описании позволил создать обширный каталог паттернов, проверив каждый из них на состоятельность.

## Назовите основные характеристики шаблонов.

+ __Имя__ - все шаблоны имеют уникальное имя, служащее для их идентификации;
+ __Назначение__    назначение данного шаблона;
+ __Задача__ - задача, которую шаблон позволяет решить;
+ __Способ решения__ - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;
+ __Участники__    - сущности, принимающие участие в решении задачи;
+ __Следствия__    - последствия от использования шаблона как результат действий, выполняемых в шаблоне;
+ __Реализация__ - возможный вариант реализации шаблона.

[к оглавлению](#Шаблоны-проектирования)

## Типы шаблонов проектирования. [Middle+]

+ Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует эти шаблоны в той или иной форме.
+ Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты, делегирует создание объектов другому объекту.
+ Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.
+ Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры основных шаблонов проектирования. 

+ __Фабричный метод (Factory Method)__ - это шаблон, который используется для создания объектов без необходимости определения их конкретных классов в коде. Вместо этого используется метод фабрики, который определяет, какой тип объекта должен быть создан на основе заданных параметров. Например, фабрика может создавать объекты различных классов, в зависимости от входных параметров, таких как тип, размер и цвет.
+ __Декоратор (Decorator)__ - это шаблон, который используется для добавления дополнительной функциональности к существующему объекту без изменения его класса. Декораторы используются, когда требуется добавить дополнительные возможности, такие как шифрование, сжатие или логирование, без изменения существующего кода. Например, декоратор может добавлять дополнительную функциональность к объекту, который записывает данные в файл, чтобы автоматически создавать резервные копии данных.
+ __Singleton__ - это шаблон, который гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Это полезно в ситуациях, когда нужно обеспечить, чтобы некоторый ресурс был доступен глобально и в единственном экземпляре. Примером может служить класс базы данных, который должен быть доступен везде в приложении, но может использоваться только одним клиентом одновременно.
+ __Proxy__ - это шаблон, который позволяет создать объект-заместитель для другого объекта, который может быть использован вместо оригинального объекта. Это позволяет контролировать доступ к оригинальному объекту и выполнение некоторых дополнительных операций при обращении к нему. Примером может служить объект, представляющий удаленный сервис, к которому нужно обращаться через прокси-объект, чтобы обеспечить безопасность и управление доступом.

+ __Делегирование (Delegation pattern)__ - Сущность внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.
+ __Функциональный дизайн (Functional design)__ - Гарантирует, что каждая сущность имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие.
+ __Неизменяемый интерфейс (Immutable interface)__ - Создание неизменяемого объекта.
+ __Интерфейс (Interface)__ - Общий метод структурирования сущностей, облегчающий их понимание. 
+ __Интерфейс-маркер (Marker interface)__ - В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого применяются атрибуты или аннотации.
+ __Контейнер свойств (Property container)__ - Позволяет добавлять дополнительные свойства сущности в контейнер внутри себя, вместо расширения новыми свойствами.
+ __Канал событий (Event channel)__ - Создаёт централизованный канал для событий. Использует сущность-представитель для подписки и сущность-представитель для публикации события в канале. Представитель существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от более чем одной сущности, даже если он зарегистрирован только на одном канале.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры порождающих шаблонов проектирования.

+ __Абстрактная фабрика (Abstract factory)__ - Класс, который представляет собой интерфейс для создания других классов.
+ __Строитель (Builder)__ - Класс, который представляет собой интерфейс для создания сложного объекта.
+ __Фабричный метод (Factory method)__ - Делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.
+ __Прототип (Prototype)__ - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.
+ __Одиночка (Singleton)__ - Класс, который может иметь только один экземпляр.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры структурных шаблонов проектирования. 

+ __Адаптер (Adapter)__ - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс. 
+ __Мост (Bridge)__ - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо. 
+ __Компоновщик (Composite)__ - Объект, который объединяет в себе объекты, подобные ему самому. 
+ __Декоратор (Decorator)__ - Класс, расширяющий функциональность другого класса без использования наследования. 
+ __Фасад (Facade)__ - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое. 
+ __Приспособленец (Flyweight)__ - Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не являющийся таковым. 
+ __Заместитель (Proxy)__ - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры поведенческих шаблонов проектирования. 

+ __Цепочка обязанностей (Chain of responsibility)__ - Предназначен для организации в системе уровней ответственности.
+ __Команда (Command)__ - Представляет действие. Объект команды заключает в себе само действие и его параметры.
+ __Интерпретатор (Interpreter)__ - Решает часто встречающуюся, но подверженную изменениям, задачу.
+ __Итератор (Iterator)__ - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.
+ __Посредник (Mediator)__ - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.
+ __Хранитель (Memento)__ - Позволяет, не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях.
+ __Наблюдатель (Observer)__ - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.
+ __Состояние (State)__ - Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.
+ __Стратегия (Strategy)__ - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
+ __Шаблонный метод (Template method)__ - Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
+ __Посетитель (Visitor)__ - Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы.

[к оглавлению](#Шаблоны-проектирования)

## Расскажите о паттерне Singleton
__Singleton__ — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

__Проблема__
Одиночка решает сразу две проблемы, нарушая принцип единственной ответственности класса.
+ __Гарантирует наличие единственного экземпляра класса.__ Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.
Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. В этом случае хотелось бы получить старый объект, вместо создания нового.
Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект.
+ __Предоставляет глобальную точку доступа.__ Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.
Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему простой и доступный интерфейс.
Интересно, что в наше время паттерн стал настолько известен, что теперь люди называют «одиночками» даже те классы, которые решают лишь одну из проблем, перечисленных выше.

__Решение__
Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.
Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

__Структура__
![image](https://user-images.githubusercontent.com/116163780/235869531-171bcb3c-b2ca-4e1c-9fd9-1232078eb832.png)

__Применимость__
+ Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы). Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода. Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.
+ Когда вам хочется иметь больше контроля над глобальными переменными. В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса, поэтому вы всегда уверены в наличии лишь одного объекта-одиночки. Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек, поменяв код в одном месте (метод `getInstance()`).

__Шаги реализации__
+ Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.
+ Объявите статический создающий метод, который будет использоваться для получения одиночки.
+ Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки.
+ Сделайте конструктор класса приватным.
+ В клиентском коде замените вызовы конструктора одиночка вызовами его создающего метода.

__Преимущества__
+ Гарантирует наличие единственного экземпляра класса.
+ Предоставляет к нему глобальную точку доступа.
+ Реализует отложенную инициализацию объекта-одиночки.

__Недостатки__
+ Нарушает принцип единственной ответственности класса.
+ Маскирует плохой дизайн.
+ Проблемы мультипоточности.
+ Требует постоянного создания Mock-объектов при юнит-тестировании.

## Способы реализации паттерна Singleton
+ Самый простой подход - использовать статический экземпляр класса с закрытым конструктором, чтобы гарантировать, что объект класса создается только один раз и его можно получить через метод `getInstance()`. Вот пример:
```java
public class Singleton {
    private static Singleton instance;

    private Singleton() { // закрытый конструктор
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
В этом примере `getInstance()` проверяет, существует ли экземпляр Singleton, и создает его, если нет. Этот подход может не работать в многопоточной среде, так как два потока могут одновременно проверить, что `instance` равно `null`, и создать два разных экземпляра.
+ Другой подход - использовать двойную проверку на `null` в методе `getInstance()` и синхронизировать его, чтобы гарантировать, что только один поток может создавать экземпляр. Вот пример:
```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() { // закрытый конструктор
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
В этом примере использована двойная проверка на `null` для гарантии создания единственного экземпляра класса, и переменная `instance` объявлена как `volatile` для обеспечения правильного многопоточного поведения. Синхронизация обеспечивает правильную работу в многопоточной среде, но может снизить производительность в случае высокой нагрузки на приложение.
+ Еще один подход - использовать перечисление (enum) для определения Singleton. Перечисления в Java являются singleton-ами по умолчанию, и каждый элемент перечисления создается только один раз. Вот пример:
```java
public enum Singleton {
    INSTANCE;

    public void doSomething() {
        // реализация метода
    }
}
```
В этом примере Singleton определен как единственный элемент перечисления, и его методы могут быть вызваны из других частей приложения через `Singleton.INSTANCE`. Этот подход гарантирует, что экземпляр Singleton создается только один раз в процессе загрузки класса и может быть использован где угодно в приложении.

## Приведите примеры использования паттерна Singleton
+ Логгирование - для создания единственного объекта логгера, который может использоваться во всем приложении, и записи сообщений лога в единое место.
+ Работа с базой данных - для создания единственного объекта соединения с базой данных, который может использоваться во всем приложении, и обеспечения многопоточной безопасности и оптимизации ресурсов.
+ Работа с файлами конфигурации - для создания единственного объекта файла конфигурации, который может использоваться во всем приложении, и чтения настроек из единого места.
+ Работа с кэшем - для создания единственного объекта кэша, который может использоваться во всем приложении, и обеспечения многопоточной безопасности и оптимизации ресурсов при кэшировании данных.
+ Игровые приложения - для создания единственного объекта игрового движка, который может использоваться во всех частях игры и обеспечивать единую логику и настройки игровой среды.
+ Создание объекта управления ресурсами - для создания единственного объекта управления ресурсами, который может использоваться во всем приложении, и обеспечивать управление ресурсами, такими как память, потоки и файловая система.
+ Работа с API - для создания единственного объекта API-клиента, который может использоваться во всем приложении, и обеспечения многопоточной безопасности и оптимизации ресурсов при обращении к API.
+ Кеширование результатов - для создания единственного объекта кеша, который может использоваться во всем приложении, и обеспечения быстрого доступа к результатам предыдущих операций.

## Расскажите о паттерне Decorator
__Decorator__ — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки» (другой объект с таким же интерфейсом). Этот шаблон позволяет добавлять новые возможности, не изменяя уже существующий код.
Каждый декоратор имеет тот же интерфейс, что и исходный объект, поэтому они могут быть вложены друг в друга.

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.
Он статичен. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс.
Он не разрешает наследовать поведение нескольких классов одновременно. Из-за этого вам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.
Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией . Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн Декоратор.
![image](https://user-images.githubusercontent.com/116163780/235887505-8ab2362a-5ddb-46df-8c2e-de02d29ea3bc.png)
Декоратор имеет альтернативное название — обёртка. Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.
Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

__Применимость__
+ Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.
Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.
+ Когда нельзя расширить обязанности объекта с помощью наследования.
Во многих языках программирования есть ключевое слово final, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью Декоратора.

__Шаги реализации__
+ Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.
+ Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.
+ Создайте класс конкретного компонента и поместите в него основную бизнес-логику.
+ Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все методы базового декоратора должны делегировать действие вложенному объекту.
+ И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.
+ Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.
+ Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

__Преимущества__
+ Большая гибкость, чем у наследования.
+ Позволяет добавлять обязанности на лету.
+ Можно добавлять несколько новых обязанностей сразу.
+ Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

__Недостатки__
+ Трудно конфигурировать многократно обёрнутые объекты.
+ Обилие крошечных классов.

## Приведите пример использования шаблона Decorator
Примером использования шаблона Decorator может служить создание текстового редактора. Исходный объект - это базовый текстовый редактор, а декораторы - это различные функциональные возможности, такие как проверка орфографии, автокоррекция, подсветка синтаксиса и т.д. Каждый декоратор может быть добавлен к исходному объекту по отдельности, создавая новые комбинации функциональности.

Вот пример реализации шаблона Decorator на языке Java:
```java
// Интерфейс, определяющий общий интерфейс для объектов и декораторов
public interface TextEditor {
    public String getText();
    public void setText(String text);
}

// Базовый текстовый редактор
public class BasicTextEditor implements TextEditor {
    private String text;

    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
}

// Абстрактный декоратор
public abstract class TextEditorDecorator implements TextEditor {
    private TextEditor editor;

    public TextEditorDecorator(TextEditor editor) {
        this.editor = editor;
    }

    public String getText() {
        return editor.getText();
    }
    public void setText(String text) {
        editor.setText(text);
    }
}

// Декоратор проверки орфографии
public class SpellCheckDecorator extends TextEditorDecorator {
    public SpellCheckDecorator(TextEditor editor) {
        super(editor);
    }

    public String getText() {
        String text = super.getText();
        // проверка орфографии
        return text;
    }
}

// Декоратор автокоррекции
public class AutoCorrectDecorator extends TextEditorDecorator {
    public AutoCorrectDecorator(TextEditor editor) {
        super(editor);
    }

    public void setText(String text) {
        // автокоррекция текста
        super.setText(text);
    }
}
```
В этом примере интерфейс TextEditor определяет общий интерфейс для базового текстового редактора и декораторов. Класс BasicTextEditor является базовым текстовым редактором, который реализует этот интерфейс. Абстрактный класс TextEditorDecorator является

Вот еще несколько примеров использования паттерна Decorator:
+ Кофейная машина - для создания декораторов, которые добавляют к кофе новые вкусовые свойства, например, сиропы, взбитые сливки и т.д.
+ Парсер - для создания декораторов, которые добавляют к парсеру новые возможности, такие как проверка правописания, автокоррекция, конвертирование форматов и т.д.
+ Графический интерфейс - для создания декораторов, которые добавляют к окнам новые возможности, такие как прокрутка, управление размерами, анимации и т.д.
+ Файловый поток - для создания декораторов, которые добавляют к файловым потокам новые функциональные возможности, такие как шифрование, сжатие, буферизация и т.д.
+ Рисование - для создания декораторов, которые добавляют к рисованию новые возможности, такие как текстуры, шейдеры, эффекты и т.д.
+ Музыкальный плеер - для создания декораторов, которые добавляют к музыкальному плееру новые функциональные возможности, такие как эквалайзер, визуализация, плейлисты и т.д.
+ Архиватор - для создания декораторов, которые добавляют к архиватору новые возможности, такие как шифрование, сжатие, проверка целостности и т.д.
+ Сетевые соединения - для создания декораторов, которые добавляют к сетевым соединениям новые возможности, такие как управление буфером, аутентификация, шифрование и т.д.

## Расскажите о паттерне Factory Method
__Factory Method__ — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

__Проблема__
Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса Грузовик.
В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.
Большая часть существующего кода жёстко привязана к классам Грузовиков. Чтобы добавить в программу классы морских Судов, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.
В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

__Решение__
Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод.































## Что такое _«антипаттерн»_? Какие антипаттерны вы знаете? 

__Антипаттерн (anti-pattern)__ — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.
__Poltergeists (полтергейсты)__ - это классы с ограниченной ответственностью и ролью в системе, чьё единственное предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. Полтергейсты нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они чрезмерно запутанны, сложны для понимания и трудны в сопровождении. Обычно такие классы задумываются как классы-контроллеры, которые существуют только для вызова методов других классов, зачастую в предопределенной последовательности.

Признаки появления и последствия антипаттерна
+ Избыточные межклассовые связи.
+ Временные ассоциации.
+ Классы без состояния (содержащие только методы и константы).
+ Временные объекты и классы (с непродолжительным временем жизни).
+ Классы с единственным методом, который предназначен только для создания или вызова других классов посредством временной ассоциации.
+ Классы с именами методов в стиле «управления», такие как startProcess.

Типичные причины
+ Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).
+ Неправильный выбор пути решения задачи.
+ Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.

Термины:
+ __Внесенная сложность (Introduced complexity)__: Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».
+ __Инверсия абстракции (Abstraction inversion)__: Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.
+ __Неопределённая точка зрения (Ambiguous viewpoint)__: Представление модели без спецификации её точки рассмотрения.
+ __Большой комок грязи (Big ball of mud)__: Система с нераспознаваемой структурой.
+ __Божественный объект (God object)__: Концентрация слишком большого количества функций в одной части системы (классе).
+ __Затычка на ввод данных (Input kludge)__: Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.
+ __Раздувание интерфейса (Interface bloat)__: Разработка интерфейса очень мощным и очень сложным для реализации.
+ __Волшебная кнопка (Magic pushbutton)__: Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.
+ __Перестыковка (Re-Coupling)__: Процесс внедрения ненужной зависимости.
+ __Дымоход (Stovepipe System)__: Редко поддерживаемая сборка плохо связанных компонентов.
+ __Состояние гонки (Race hazard)__: непредвидение возможности наступления событий в порядке, отличном от ожидаемого.
+ __Членовредительство (Mutilation)__: Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.
+ __Сохранение или смерть (Save or die)__: Сохранение изменений лишь при завершении приложения.

[к оглавлению](#Шаблоны-проектирования)

## Что такое _Dependency Injection_? 

__Dependency Injection (внедрение зависимости)__ - это набор паттернов и принципов разработки програмного обеспечения, которые позволяют писать слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

[к оглавлению](#Шаблоны-проектирования)

# Источники

+ [Википедия](https://ru.wikipedia.org/wiki/Шаблон_проектирования)
+ [Javenue](http://www.javenue.info/post/56)

[Вопросы для собеседования](README.md)
